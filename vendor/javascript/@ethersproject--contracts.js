import{checkResultErrors as e,Interface as t,Indexed as r}from"@ethersproject/abi";import{Provider as n}from"@ethersproject/abstract-provider";import{Signer as s,VoidSigner as i}from"@ethersproject/abstract-signer";import{getAddress as o,getContractAddress as a}from"@ethersproject/address";import{BigNumber as c}from"@ethersproject/bignumber";import{arrayify as l,isHexString as u,isBytes as d,hexlify as h,concat as p}from"@ethersproject/bytes";import{shallowCopy as g,resolveProperties as f,deepCopy as v,defineReadOnly as m,getStatic as E}from"@ethersproject/properties";import{accessListify as y}from"@ethersproject/transactions";import{Logger as _}from"@ethersproject/logger";const P="contracts/5.7.0";"use strict";var R=(void 0,function(e,t,r,n){function adopt(e){return e instanceof r?e:new r((function(t){t(e)}))}return new(r||(r=Promise))((function(r,s){function fulfilled(e){try{step(n.next(e))}catch(e){s(e)}}function rejected(e){try{step(n.throw(e))}catch(e){s(e)}}function step(e){e.done?r(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))});const T=new _(P);const w={chainId:true,data:true,from:true,gasLimit:true,gasPrice:true,nonce:true,to:true,value:true,type:true,accessList:true,maxFeePerGas:true,maxPriorityFeePerGas:true,customData:true,ccipReadEnabled:true};function resolveName(e,t){return R(this,void 0,void 0,(function*(){const r=yield t;"string"!==typeof r&&T.throwArgumentError("invalid address or ENS name","name",r);try{return o(r)}catch(e){}e||T.throwError("a provider or signer is needed to resolve ENS names",_.errors.UNSUPPORTED_OPERATION,{operation:"resolveName"});const n=yield e.resolveName(r);null==n&&T.throwArgumentError("resolver or addr is not configured for ENS name","name",r);return n}))}function resolveAddresses(e,t,r){return R(this,void 0,void 0,(function*(){return Array.isArray(r)?yield Promise.all(r.map(((r,n)=>resolveAddresses(e,Array.isArray(t)?t[n]:t[r.name],r)))):"address"===r.type?yield resolveName(e,t):"tuple"===r.type?yield resolveAddresses(e,t,r.components):"array"===r.baseType?Array.isArray(t)?yield Promise.all(t.map((t=>resolveAddresses(e,t,r.arrayChildren)))):Promise.reject(T.makeError("invalid value for array",_.errors.INVALID_ARGUMENT,{argument:"value",value:t})):t}))}function populateTransaction(e,t,r){return R(this,void 0,void 0,(function*(){let n={};r.length===t.inputs.length+1&&"object"===typeof r[r.length-1]&&(n=g(r.pop()));T.checkArgumentCount(r.length,t.inputs.length,"passed to contract");e.signer?n.from?n.from=f({override:resolveName(e.signer,n.from),signer:e.signer.getAddress()}).then((e=>R(this,void 0,void 0,(function*(){o(e.signer)!==e.override&&T.throwError("Contract with a Signer cannot override from",_.errors.UNSUPPORTED_OPERATION,{operation:"overrides.from"});return e.override})))):n.from=e.signer.getAddress():n.from&&(n.from=resolveName(e.provider,n.from));const s=yield f({args:resolveAddresses(e.signer||e.provider,r,t.inputs),address:e.resolvedAddress,overrides:f(n)||{}});const i=e.interface.encodeFunctionData(t,s.args);const a={data:i,to:s.address};const u=s.overrides;null!=u.nonce&&(a.nonce=c.from(u.nonce).toNumber());null!=u.gasLimit&&(a.gasLimit=c.from(u.gasLimit));null!=u.gasPrice&&(a.gasPrice=c.from(u.gasPrice));null!=u.maxFeePerGas&&(a.maxFeePerGas=c.from(u.maxFeePerGas));null!=u.maxPriorityFeePerGas&&(a.maxPriorityFeePerGas=c.from(u.maxPriorityFeePerGas));null!=u.from&&(a.from=u.from);null!=u.type&&(a.type=u.type);null!=u.accessList&&(a.accessList=y(u.accessList));if(null==a.gasLimit&&null!=t.gas){let e=21e3;const r=l(i);for(let t=0;t<r.length;t++){e+=4;r[t]&&(e+=64)}a.gasLimit=c.from(t.gas).add(e)}if(u.value){const e=c.from(u.value);e.isZero()||t.payable||T.throwError("non-payable method cannot override value",_.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:n.value});a.value=e}u.customData&&(a.customData=g(u.customData));u.ccipReadEnabled&&(a.ccipReadEnabled=!!u.ccipReadEnabled);delete n.nonce;delete n.gasLimit;delete n.gasPrice;delete n.from;delete n.value;delete n.type;delete n.accessList;delete n.maxFeePerGas;delete n.maxPriorityFeePerGas;delete n.customData;delete n.ccipReadEnabled;const d=Object.keys(n).filter((e=>null!=n[e]));d.length&&T.throwError(`cannot override ${d.map((e=>JSON.stringify(e))).join(",")}`,_.errors.UNSUPPORTED_OPERATION,{operation:"overrides",overrides:d});return a}))}function buildPopulate(e,t){return function(...r){return populateTransaction(e,t,r)}}function buildEstimate(e,t){const r=e.signer||e.provider;return function(...n){return R(this,void 0,void 0,(function*(){r||T.throwError("estimate require a provider or signer",_.errors.UNSUPPORTED_OPERATION,{operation:"estimateGas"});const s=yield populateTransaction(e,t,n);return yield r.estimateGas(s)}))}}function addContractWait(e,t){const r=t.wait.bind(t);t.wait=t=>r(t).then((t=>{t.events=t.logs.map((r=>{let n=v(r);let s=null;try{s=e.interface.parseLog(r)}catch(e){}if(s){n.args=s.args;n.decode=(t,r)=>e.interface.decodeEventLog(s.eventFragment,t,r);n.event=s.name;n.eventSignature=s.signature}n.removeListener=()=>e.provider;n.getBlock=()=>e.provider.getBlock(t.blockHash);n.getTransaction=()=>e.provider.getTransaction(t.transactionHash);n.getTransactionReceipt=()=>Promise.resolve(t);return n}));return t}))}function buildCall(e,t,r){const n=e.signer||e.provider;return function(...s){return R(this,void 0,void 0,(function*(){let i;if(s.length===t.inputs.length+1&&"object"===typeof s[s.length-1]){const e=g(s.pop());null!=e.blockTag&&(i=yield e.blockTag);delete e.blockTag;s.push(e)}null!=e.deployTransaction&&(yield e._deployed(i));const o=yield populateTransaction(e,t,s);const a=yield n.call(o,i);try{let n=e.interface.decodeFunctionResult(t,a);r&&1===t.outputs.length&&(n=n[0]);return n}catch(t){if(t.code===_.errors.CALL_EXCEPTION){t.address=e.address;t.args=s;t.transaction=o}throw t}}))}}function buildSend(e,t){return function(...r){return R(this,void 0,void 0,(function*(){e.signer||T.throwError("sending a transaction requires a signer",_.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction"});null!=e.deployTransaction&&(yield e._deployed());const n=yield populateTransaction(e,t,r);const s=yield e.signer.sendTransaction(n);addContractWait(e,s);return s}))}}function buildDefault(e,t,r){return t.constant?buildCall(e,t,r):buildSend(e,t)}function getEventTag(e){return!e.address||null!=e.topics&&0!==e.topics.length?(e.address||"*")+"@"+(e.topics?e.topics.map((e=>Array.isArray(e)?e.join("|"):e)).join(":"):""):"*"}class RunningEvent{constructor(e,t){m(this,"tag",e);m(this,"filter",t);this._listeners=[]}addListener(e,t){this._listeners.push({listener:e,once:t})}removeListener(e){let t=false;this._listeners=this._listeners.filter((r=>{if(t||r.listener!==e)return true;t=true;return false}))}removeAllListeners(){this._listeners=[]}listeners(){return this._listeners.map((e=>e.listener))}listenerCount(){return this._listeners.length}run(e){const t=this.listenerCount();this._listeners=this._listeners.filter((t=>{const r=e.slice();setTimeout((()=>{t.listener.apply(this,r)}),0);return!t.once}));return t}prepareEvent(e){}getEmit(e){return[e]}}class ErrorRunningEvent extends RunningEvent{constructor(){super("error",null)}}class FragmentRunningEvent extends RunningEvent{constructor(e,t,r,n){const s={address:e};let i=t.getEventTopic(r);if(n){i!==n[0]&&T.throwArgumentError("topic mismatch","topics",n);s.topics=n.slice()}else s.topics=[i];super(getEventTag(s),s);m(this,"address",e);m(this,"interface",t);m(this,"fragment",r)}prepareEvent(e){super.prepareEvent(e);e.event=this.fragment.name;e.eventSignature=this.fragment.format();e.decode=(e,t)=>this.interface.decodeEventLog(this.fragment,e,t);try{e.args=this.interface.decodeEventLog(this.fragment,e.data,e.topics)}catch(t){e.args=null;e.decodeError=t}}getEmit(t){const r=e(t.args);if(r.length)throw r[0].error;const n=(t.args||[]).slice();n.push(t);return n}}class WildcardRunningEvent extends RunningEvent{constructor(e,t){super("*",{address:e});m(this,"address",e);m(this,"interface",t)}prepareEvent(e){super.prepareEvent(e);try{const t=this.interface.parseLog(e);e.event=t.name;e.eventSignature=t.signature;e.decode=(e,r)=>this.interface.decodeEventLog(t.eventFragment,e,r);e.args=t.args}catch(e){}}}class BaseContract{constructor(e,t,r){m(this,"interface",E(new.target,"getInterface")(t));if(null==r){m(this,"provider",null);m(this,"signer",null)}else if(s.isSigner(r)){m(this,"provider",r.provider||null);m(this,"signer",r)}else if(n.isProvider(r)){m(this,"provider",r);m(this,"signer",null)}else T.throwArgumentError("invalid signer or provider","signerOrProvider",r);m(this,"callStatic",{});m(this,"estimateGas",{});m(this,"functions",{});m(this,"populateTransaction",{});m(this,"filters",{});{const e={};Object.keys(this.interface.events).forEach((t=>{const r=this.interface.events[t];m(this.filters,t,((...e)=>({address:this.address,topics:this.interface.encodeFilterTopics(r,e)})));e[r.name]||(e[r.name]=[]);e[r.name].push(t)}));Object.keys(e).forEach((t=>{const r=e[t];1===r.length?m(this.filters,t,this.filters[r[0]]):T.warn(`Duplicate definition of ${t} (${r.join(", ")})`)}))}m(this,"_runningEvents",{});m(this,"_wrappedEmits",{});null==e&&T.throwArgumentError("invalid contract address or ENS name","addressOrName",e);m(this,"address",e);if(this.provider)m(this,"resolvedAddress",resolveName(this.provider,e));else try{m(this,"resolvedAddress",Promise.resolve(o(e)))}catch(e){T.throwError("provider is required to use ENS name as contract address",_.errors.UNSUPPORTED_OPERATION,{operation:"new Contract"})}this.resolvedAddress.catch((e=>{}));const i={};const a={};Object.keys(this.interface.functions).forEach((e=>{const t=this.interface.functions[e];if(a[e])T.warn(`Duplicate ABI entry for ${JSON.stringify(e)}`);else{a[e]=true;{const r=t.name;i[`%${r}`]||(i[`%${r}`]=[]);i[`%${r}`].push(e)}null==this[e]&&m(this,e,buildDefault(this,t,true));null==this.functions[e]&&m(this.functions,e,buildDefault(this,t,false));null==this.callStatic[e]&&m(this.callStatic,e,buildCall(this,t,true));null==this.populateTransaction[e]&&m(this.populateTransaction,e,buildPopulate(this,t));null==this.estimateGas[e]&&m(this.estimateGas,e,buildEstimate(this,t))}}));Object.keys(i).forEach((e=>{const t=i[e];if(t.length>1)return;e=e.substring(1);const r=t[0];try{null==this[e]&&m(this,e,this[r])}catch(e){}null==this.functions[e]&&m(this.functions,e,this.functions[r]);null==this.callStatic[e]&&m(this.callStatic,e,this.callStatic[r]);null==this.populateTransaction[e]&&m(this.populateTransaction,e,this.populateTransaction[r]);null==this.estimateGas[e]&&m(this.estimateGas,e,this.estimateGas[r])}))}static getContractAddress(e){return a(e)}static getInterface(e){return t.isInterface(e)?e:new t(e)}deployed(){return this._deployed()}_deployed(e){this._deployedPromise||(this.deployTransaction?this._deployedPromise=this.deployTransaction.wait().then((()=>this)):this._deployedPromise=this.provider.getCode(this.address,e).then((e=>{"0x"===e&&T.throwError("contract not deployed",_.errors.UNSUPPORTED_OPERATION,{contractAddress:this.address,operation:"getDeployed"});return this})));return this._deployedPromise}fallback(e){this.signer||T.throwError("sending a transactions require a signer",_.errors.UNSUPPORTED_OPERATION,{operation:"sendTransaction(fallback)"});const t=g(e||{});["from","to"].forEach((function(e){null!=t[e]&&T.throwError("cannot override "+e,_.errors.UNSUPPORTED_OPERATION,{operation:e})}));t.to=this.resolvedAddress;return this.deployed().then((()=>this.signer.sendTransaction(t)))}connect(e){"string"===typeof e&&(e=new i(e,this.provider));const t=new this.constructor(this.address,this.interface,e);this.deployTransaction&&m(t,"deployTransaction",this.deployTransaction);return t}attach(e){return new this.constructor(e,this.interface,this.signer||this.provider)}static isIndexed(e){return r.isIndexed(e)}_normalizeRunningEvent(e){return this._runningEvents[e.tag]?this._runningEvents[e.tag]:e}_getRunningEvent(e){if("string"===typeof e){if("error"===e)return this._normalizeRunningEvent(new ErrorRunningEvent);if("event"===e)return this._normalizeRunningEvent(new RunningEvent("event",null));if("*"===e)return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface));const t=this.interface.getEvent(e);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,t))}if(e.topics&&e.topics.length>0){try{const t=e.topics[0];if("string"!==typeof t)throw new Error("invalid topic");const r=this.interface.getEvent(t);return this._normalizeRunningEvent(new FragmentRunningEvent(this.address,this.interface,r,e.topics))}catch(e){}const t={address:this.address,topics:e.topics};return this._normalizeRunningEvent(new RunningEvent(getEventTag(t),t))}return this._normalizeRunningEvent(new WildcardRunningEvent(this.address,this.interface))}_checkRunningEvents(e){if(0===e.listenerCount()){delete this._runningEvents[e.tag];const t=this._wrappedEmits[e.tag];if(t&&e.filter){this.provider.off(e.filter,t);delete this._wrappedEmits[e.tag]}}}_wrapEvent(e,t,r){const n=v(t);n.removeListener=()=>{if(r){e.removeListener(r);this._checkRunningEvents(e)}};n.getBlock=()=>this.provider.getBlock(t.blockHash);n.getTransaction=()=>this.provider.getTransaction(t.transactionHash);n.getTransactionReceipt=()=>this.provider.getTransactionReceipt(t.transactionHash);e.prepareEvent(n);return n}_addEventListener(e,t,r){this.provider||T.throwError("events require a provider or a signer with a provider",_.errors.UNSUPPORTED_OPERATION,{operation:"once"});e.addListener(t,r);this._runningEvents[e.tag]=e;if(!this._wrappedEmits[e.tag]){const wrappedEmit=r=>{let n=this._wrapEvent(e,r,t);if(null==n.decodeError)try{const t=e.getEmit(n);this.emit(e.filter,...t)}catch(e){n.decodeError=e.error}null!=e.filter&&this.emit("event",n);null!=n.decodeError&&this.emit("error",n.decodeError,n)};this._wrappedEmits[e.tag]=wrappedEmit;null!=e.filter&&this.provider.on(e.filter,wrappedEmit)}}queryFilter(e,t,r){const n=this._getRunningEvent(e);const s=g(n.filter);if("string"===typeof t&&u(t,32)){null!=r&&T.throwArgumentError("cannot specify toBlock with blockhash","toBlock",r);s.blockHash=t}else{s.fromBlock=null!=t?t:0;s.toBlock=null!=r?r:"latest"}return this.provider.getLogs(s).then((e=>e.map((e=>this._wrapEvent(n,e,null)))))}on(e,t){this._addEventListener(this._getRunningEvent(e),t,false);return this}once(e,t){this._addEventListener(this._getRunningEvent(e),t,true);return this}emit(e,...t){if(!this.provider)return false;const r=this._getRunningEvent(e);const n=r.run(t)>0;this._checkRunningEvents(r);return n}listenerCount(e){return this.provider?null==e?Object.keys(this._runningEvents).reduce(((e,t)=>e+this._runningEvents[t].listenerCount()),0):this._getRunningEvent(e).listenerCount():0}listeners(e){if(!this.provider)return[];if(null==e){const e=[];for(let t in this._runningEvents)this._runningEvents[t].listeners().forEach((t=>{e.push(t)}));return e}return this._getRunningEvent(e).listeners()}removeAllListeners(e){if(!this.provider)return this;if(null==e){for(const e in this._runningEvents){const t=this._runningEvents[e];t.removeAllListeners();this._checkRunningEvents(t)}return this}const t=this._getRunningEvent(e);t.removeAllListeners();this._checkRunningEvents(t);return this}off(e,t){if(!this.provider)return this;const r=this._getRunningEvent(e);r.removeListener(t);this._checkRunningEvents(r);return this}removeListener(e,t){return this.off(e,t)}}class Contract extends BaseContract{}class ContractFactory{constructor(e,t,r){let n=null;n="string"===typeof t?t:d(t)?h(t):t&&"string"===typeof t.object?t.object:"!";"0x"!==n.substring(0,2)&&(n="0x"+n);(!u(n)||n.length%2)&&T.throwArgumentError("invalid bytecode","bytecode",t);r&&!s.isSigner(r)&&T.throwArgumentError("invalid signer","signer",r);m(this,"bytecode",n);m(this,"interface",E(new.target,"getInterface")(e));m(this,"signer",r||null)}getDeployTransaction(...e){let t={};if(e.length===this.interface.deploy.inputs.length+1&&"object"===typeof e[e.length-1]){t=g(e.pop());for(const e in t)if(!w[e])throw new Error("unknown transaction override "+e)}["data","from","to"].forEach((e=>{null!=t[e]&&T.throwError("cannot override "+e,_.errors.UNSUPPORTED_OPERATION,{operation:e})}));if(t.value){const e=c.from(t.value);e.isZero()||this.interface.deploy.payable||T.throwError("non-payable constructor cannot override value",_.errors.UNSUPPORTED_OPERATION,{operation:"overrides.value",value:t.value})}T.checkArgumentCount(e.length,this.interface.deploy.inputs.length," in Contract constructor");t.data=h(p([this.bytecode,this.interface.encodeDeploy(e)]));return t}deploy(...e){return R(this,void 0,void 0,(function*(){let t={};e.length===this.interface.deploy.inputs.length+1&&(t=e.pop());T.checkArgumentCount(e.length,this.interface.deploy.inputs.length," in Contract constructor");const r=yield resolveAddresses(this.signer,e,this.interface.deploy.inputs);r.push(t);const n=this.getDeployTransaction(...r);const s=yield this.signer.sendTransaction(n);const i=E(this.constructor,"getContractAddress")(s);const o=E(this.constructor,"getContract")(i,this.interface,this.signer);addContractWait(o,s);m(o,"deployTransaction",s);return o}))}attach(e){return this.constructor.getContract(e,this.interface,this.signer)}connect(e){return new this.constructor(this.interface,this.bytecode,e)}static fromSolidity(e,t){null==e&&T.throwError("missing compiler output",_.errors.MISSING_ARGUMENT,{argument:"compilerOutput"});"string"===typeof e&&(e=JSON.parse(e));const r=e.abi;let n=null;e.bytecode?n=e.bytecode:e.evm&&e.evm.bytecode&&(n=e.evm.bytecode);return new this(r,n,t)}static getInterface(e){return Contract.getInterface(e)}static getContractAddress(e){return a(e)}static getContract(e,t,r){return new Contract(e,t,r)}}export{BaseContract,Contract,ContractFactory};

