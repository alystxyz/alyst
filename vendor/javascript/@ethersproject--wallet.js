import{getAddress as e}from"@ethersproject/address";import{Provider as r}from"@ethersproject/abstract-provider";import{Signer as t}from"@ethersproject/abstract-signer";import{isHexString as n,joinSignature as i,arrayify as o,hexDataSlice as s,concat as a}from"@ethersproject/bytes";import{hashMessage as c,_TypedDataEncoder as m}from"@ethersproject/hash";import{defaultPath as p,HDNode as h,entropyToMnemonic as l}from"@ethersproject/hdnode";import{keccak256 as u}from"@ethersproject/keccak256";import{defineReadOnly as d,resolveProperties as f}from"@ethersproject/properties";import{randomBytes as g}from"@ethersproject/random";import{SigningKey as y}from"@ethersproject/signing-key";import{encryptKeystore as v,decryptJsonWallet as K,decryptJsonWalletSync as w}from"@ethersproject/json-wallets";import{computeAddress as E,serialize as j,recoverAddress as _}from"@ethersproject/transactions";import{Logger as D}from"@ethersproject/logger";const A="wallet/5.7.0";"use strict";var b=(void 0,function(e,r,t,n){function adopt(e){return e instanceof t?e:new t((function(r){r(e)}))}return new(t||(t=Promise))((function(t,i){function fulfilled(e){try{step(n.next(e))}catch(e){i(e)}}function rejected(e){try{step(n.throw(e))}catch(e){i(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((n=n.apply(e,r||[])).next())}))});const M=new D(A);function isAccount(e){return null!=e&&n(e.privateKey,32)&&null!=e.address}function hasMnemonic(e){const r=e.mnemonic;return r&&r.phrase}class Wallet extends t{constructor(t,n){super();if(isAccount(t)){const r=new y(t.privateKey);d(this,"_signingKey",(()=>r));d(this,"address",E(this.publicKey));this.address!==e(t.address)&&M.throwArgumentError("privateKey/address mismatch","privateKey","[REDACTED]");if(hasMnemonic(t)){const e=t.mnemonic;d(this,"_mnemonic",(()=>({phrase:e.phrase,path:e.path||p,locale:e.locale||"en"})));const r=this.mnemonic;const n=h.fromMnemonic(r.phrase,null,r.locale).derivePath(r.path);E(n.privateKey)!==this.address&&M.throwArgumentError("mnemonic/address mismatch","privateKey","[REDACTED]")}else d(this,"_mnemonic",(()=>null))}else{if(y.isSigningKey(t)){"secp256k1"!==t.curve&&M.throwArgumentError("unsupported curve; must be secp256k1","privateKey","[REDACTED]");d(this,"_signingKey",(()=>t))}else{"string"===typeof t&&t.match(/^[0-9a-f]*$/i)&&64===t.length&&(t="0x"+t);const e=new y(t);d(this,"_signingKey",(()=>e))}d(this,"_mnemonic",(()=>null));d(this,"address",E(this.publicKey))}n&&!r.isProvider(n)&&M.throwArgumentError("invalid provider","provider",n);d(this,"provider",n||null)}get mnemonic(){return this._mnemonic()}get privateKey(){return this._signingKey().privateKey}get publicKey(){return this._signingKey().publicKey}getAddress(){return Promise.resolve(this.address)}connect(e){return new Wallet(this,e)}signTransaction(r){return f(r).then((t=>{if(null!=t.from){e(t.from)!==this.address&&M.throwArgumentError("transaction from address mismatch","transaction.from",r.from);delete t.from}const n=this._signingKey().signDigest(u(j(t)));return j(t,n)}))}signMessage(e){return b(this,void 0,void 0,(function*(){return i(this._signingKey().signDigest(c(e)))}))}_signTypedData(e,r,t){return b(this,void 0,void 0,(function*(){const n=yield m.resolveNames(e,r,t,(e=>{null==this.provider&&M.throwError("cannot resolve ENS names without a provider",D.errors.UNSUPPORTED_OPERATION,{operation:"resolveName",value:e});return this.provider.resolveName(e)}));return i(this._signingKey().signDigest(m.hash(n.domain,r,n.value)))}))}encrypt(e,r,t){if("function"===typeof r&&!t){t=r;r={}}if(t&&"function"!==typeof t)throw new Error("invalid callback");r||(r={});return v(this,e,r,t)}static createRandom(e){let r=g(16);e||(e={});e.extraEntropy&&(r=o(s(u(a([r,e.extraEntropy])),0,16)));const t=l(r,e.locale);return Wallet.fromMnemonic(t,e.path,e.locale)}static fromEncryptedJson(e,r,t){return K(e,r,t).then((e=>new Wallet(e)))}static fromEncryptedJsonSync(e,r){return new Wallet(w(e,r))}static fromMnemonic(e,r,t){r||(r=p);return new Wallet(h.fromMnemonic(e,null,t).derivePath(r))}}function verifyMessage(e,r){return _(c(e),r)}function verifyTypedData(e,r,t,n){return _(m.hash(e,r,t),n)}export{Wallet,verifyMessage,verifyTypedData};

