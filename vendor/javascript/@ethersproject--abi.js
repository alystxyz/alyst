import{BigNumber as t}from"@ethersproject/bignumber";import{defineReadOnly as e,Description as r,getStatic as n}from"@ethersproject/properties";import{Logger as a}from"@ethersproject/logger";import{hexConcat as s,concat as o,arrayify as i,hexlify as u,hexZeroPad as c,hexDataSlice as l,isHexString as h}from"@ethersproject/bytes";import{getAddress as m}from"@ethersproject/address";import{MaxUint256 as p,One as d,NegativeOne as g,Zero as f}from"@ethersproject/constants";import{toUtf8Bytes as y,toUtf8String as b}from"@ethersproject/strings";import{id as w}from"@ethersproject/hash";import{keccak256 as E}from"@ethersproject/keccak256";const v="abi/5.7.0";"use strict";const _=new a(v);const F={};let A={calldata:true,memory:true,storage:true};let T={calldata:true,memory:true};function checkModifier(t,e){if("bytes"===t||"string"===t){if(A[e])return true}else if("address"===t){if("payable"===e)return true}else if((t.indexOf("[")>=0||"tuple"===t)&&T[e])return true;(A[e]||"payable"===e)&&_.throwArgumentError("invalid modifier","name",e);return false}function parseParamType(t,e){let r=t;function throwError(e){_.throwArgumentError(`unexpected character at position ${e}`,"param",t)}t=t.replace(/\s/g," ");function newNode(t){let r={type:"",name:"",parent:t,state:{allowType:true}};e&&(r.indexed=false);return r}let n={type:"",name:"",state:{allowType:true}};let a=n;for(let r=0;r<t.length;r++){let n=t[r];switch(n){case"(":a.state.allowType&&""===a.type?a.type="tuple":a.state.allowParams||throwError(r);a.state.allowType=false;a.type=verifyType(a.type);a.components=[newNode(a)];a=a.components[0];break;case")":delete a.state;if("indexed"===a.name){e||throwError(r);a.indexed=true;a.name=""}checkModifier(a.type,a.name)&&(a.name="");a.type=verifyType(a.type);let t=a;a=a.parent;a||throwError(r);delete t.parent;a.state.allowParams=false;a.state.allowName=true;a.state.allowArray=true;break;case",":delete a.state;if("indexed"===a.name){e||throwError(r);a.indexed=true;a.name=""}checkModifier(a.type,a.name)&&(a.name="");a.type=verifyType(a.type);let s=newNode(a.parent);a.parent.components.push(s);delete a.parent;a=s;break;case" ":if(a.state.allowType&&""!==a.type){a.type=verifyType(a.type);delete a.state.allowType;a.state.allowName=true;a.state.allowParams=true}if(a.state.allowName&&""!==a.name)if("indexed"===a.name){e||throwError(r);a.indexed&&throwError(r);a.indexed=true;a.name=""}else checkModifier(a.type,a.name)?a.name="":a.state.allowName=false;break;case"[":a.state.allowArray||throwError(r);a.type+=n;a.state.allowArray=false;a.state.allowName=false;a.state.readArray=true;break;case"]":a.state.readArray||throwError(r);a.type+=n;a.state.readArray=false;a.state.allowArray=true;a.state.allowName=true;break;default:if(a.state.allowType){a.type+=n;a.state.allowParams=true;a.state.allowArray=true}else if(a.state.allowName){a.name+=n;delete a.state.allowArray}else a.state.readArray?a.type+=n:throwError(r)}}a.parent&&_.throwArgumentError("unexpected eof","param",t);delete n.state;if("indexed"===a.name){e||throwError(r.length-7);a.indexed&&throwError(r.length-7);a.indexed=true;a.name=""}else checkModifier(a.type,a.name)&&(a.name="");n.type=verifyType(n.type);return n}function populate(t,r){for(let n in r)e(t,n,r[n])}const C=Object.freeze({sighash:"sighash",minimal:"minimal",full:"full",json:"json"});const x=new RegExp(/^(.*)\[([0-9]*)\]$/);class ParamType{constructor(t,e){t!==F&&_.throwError("use fromString",a.errors.UNSUPPORTED_OPERATION,{operation:"new ParamType()"});populate(this,e);let r=this.type.match(x);populate(this,r?{arrayLength:parseInt(r[2]||"-1"),arrayChildren:ParamType.fromObject({type:r[1],components:this.components}),baseType:"array"}:{arrayLength:null,arrayChildren:null,baseType:null!=this.components?"tuple":this.type});this._isParamType=true;Object.freeze(this)}format(t){t||(t=C.sighash);C[t]||_.throwArgumentError("invalid format type","format",t);if(t===C.json){let e={type:"tuple"===this.baseType?"tuple":this.type,name:this.name||void 0};"boolean"===typeof this.indexed&&(e.indexed=this.indexed);this.components&&(e.components=this.components.map((e=>JSON.parse(e.format(t)))));return JSON.stringify(e)}let e="";if("array"===this.baseType){e+=this.arrayChildren.format(t);e+="["+(this.arrayLength<0?"":String(this.arrayLength))+"]"}else if("tuple"===this.baseType){t!==C.sighash&&(e+=this.type);e+="("+this.components.map((e=>e.format(t))).join(t===C.full?", ":",")+")"}else e+=this.type;if(t!==C.sighash){true===this.indexed&&(e+=" indexed");t===C.full&&this.name&&(e+=" "+this.name)}return e}static from(t,e){return"string"===typeof t?ParamType.fromString(t,e):ParamType.fromObject(t)}static fromObject(t){return ParamType.isParamType(t)?t:new ParamType(F,{name:t.name||null,type:verifyType(t.type),indexed:null==t.indexed?null:!!t.indexed,components:t.components?t.components.map(ParamType.fromObject):null})}static fromString(t,e){function ParamTypify(t){return ParamType.fromObject({name:t.name,type:t.type,indexed:t.indexed,components:t.components})}return ParamTypify(parseParamType(t,!!e))}static isParamType(t){return!!(null!=t&&t._isParamType)}}function parseParams(t,e){return splitNesting(t).map((t=>ParamType.fromString(t,e)))}class Fragment{constructor(t,e){t!==F&&_.throwError("use a static from method",a.errors.UNSUPPORTED_OPERATION,{operation:"new Fragment()"});populate(this,e);this._isFragment=true;Object.freeze(this)}static from(t){return Fragment.isFragment(t)?t:"string"===typeof t?Fragment.fromString(t):Fragment.fromObject(t)}static fromObject(t){if(Fragment.isFragment(t))return t;switch(t.type){case"function":return FunctionFragment.fromObject(t);case"event":return EventFragment.fromObject(t);case"constructor":return ConstructorFragment.fromObject(t);case"error":return ErrorFragment.fromObject(t);case"fallback":case"receive":return null}return _.throwArgumentError("invalid fragment object","value",t)}static fromString(t){t=t.replace(/\s/g," ");t=t.replace(/\(/g," (").replace(/\)/g,") ").replace(/\s+/g," ");t=t.trim();return"event"===t.split(" ")[0]?EventFragment.fromString(t.substring(5).trim()):"function"===t.split(" ")[0]?FunctionFragment.fromString(t.substring(8).trim()):"constructor"===t.split("(")[0].trim()?ConstructorFragment.fromString(t.trim()):"error"===t.split(" ")[0]?ErrorFragment.fromString(t.substring(5).trim()):_.throwArgumentError("unsupported fragment","value",t)}static isFragment(t){return!!(t&&t._isFragment)}}class EventFragment extends Fragment{format(t){t||(t=C.sighash);C[t]||_.throwArgumentError("invalid format type","format",t);if(t===C.json)return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});let e="";t!==C.sighash&&(e+="event ");e+=this.name+"("+this.inputs.map((e=>e.format(t))).join(t===C.full?", ":",")+") ";t!==C.sighash&&this.anonymous&&(e+="anonymous ");return e.trim()}static from(t){return"string"===typeof t?EventFragment.fromString(t):EventFragment.fromObject(t)}static fromObject(t){if(EventFragment.isEventFragment(t))return t;"event"!==t.type&&_.throwArgumentError("invalid event object","value",t);const e={name:verifyIdentifier(t.name),anonymous:t.anonymous,inputs:t.inputs?t.inputs.map(ParamType.fromObject):[],type:"event"};return new EventFragment(F,e)}static fromString(t){let e=t.match(O);e||_.throwArgumentError("invalid event string","value",t);let r=false;e[3].split(" ").forEach((t=>{switch(t.trim()){case"anonymous":r=true;break;case"":break;default:_.warn("unknown modifier: "+t)}}));return EventFragment.fromObject({name:e[1].trim(),anonymous:r,inputs:parseParams(e[2],true),type:"event"})}static isEventFragment(t){return t&&t._isFragment&&"event"===t.type}}function parseGas(e,r){r.gas=null;let n=e.split("@");if(1!==n.length){n.length>2&&_.throwArgumentError("invalid human-readable ABI signature","value",e);n[1].match(/^[0-9]+$/)||_.throwArgumentError("invalid human-readable ABI signature gas","value",e);r.gas=t.from(n[1]);return n[0]}return e}function parseModifiers(t,e){e.constant=false;e.payable=false;e.stateMutability="nonpayable";t.split(" ").forEach((t=>{switch(t.trim()){case"constant":e.constant=true;break;case"payable":e.payable=true;e.stateMutability="payable";break;case"nonpayable":e.payable=false;e.stateMutability="nonpayable";break;case"pure":e.constant=true;e.stateMutability="pure";break;case"view":e.constant=true;e.stateMutability="view";break;case"external":case"public":case"":break;default:console.log("unknown modifier: "+t)}}))}function verifyState(t){let e={constant:false,payable:true,stateMutability:"payable"};if(null!=t.stateMutability){e.stateMutability=t.stateMutability;e.constant="view"===e.stateMutability||"pure"===e.stateMutability;null!=t.constant&&!!t.constant!==e.constant&&_.throwArgumentError("cannot have constant function with mutability "+e.stateMutability,"value",t);e.payable="payable"===e.stateMutability;null!=t.payable&&!!t.payable!==e.payable&&_.throwArgumentError("cannot have payable function with mutability "+e.stateMutability,"value",t)}else if(null!=t.payable){e.payable=!!t.payable;null!=t.constant||e.payable||"constructor"===t.type||_.throwArgumentError("unable to determine stateMutability","value",t);e.constant=!!t.constant;e.constant?e.stateMutability="view":e.stateMutability=e.payable?"payable":"nonpayable";e.payable&&e.constant&&_.throwArgumentError("cannot have constant payable function","value",t)}else if(null!=t.constant){e.constant=!!t.constant;e.payable=!e.constant;e.stateMutability=e.constant?"view":"payable"}else"constructor"!==t.type&&_.throwArgumentError("unable to determine stateMutability","value",t);return e}class ConstructorFragment extends Fragment{format(t){t||(t=C.sighash);C[t]||_.throwArgumentError("invalid format type","format",t);if(t===C.json)return JSON.stringify({type:"constructor",stateMutability:"nonpayable"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:this.gas?this.gas.toNumber():void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});t===C.sighash&&_.throwError("cannot format a constructor for sighash",a.errors.UNSUPPORTED_OPERATION,{operation:"format(sighash)"});let e="constructor("+this.inputs.map((e=>e.format(t))).join(t===C.full?", ":",")+") ";this.stateMutability&&"nonpayable"!==this.stateMutability&&(e+=this.stateMutability+" ");return e.trim()}static from(t){return"string"===typeof t?ConstructorFragment.fromString(t):ConstructorFragment.fromObject(t)}static fromObject(e){if(ConstructorFragment.isConstructorFragment(e))return e;"constructor"!==e.type&&_.throwArgumentError("invalid constructor object","value",e);let r=verifyState(e);r.constant&&_.throwArgumentError("constructor cannot be constant","value",e);const n={name:null,type:e.type,inputs:e.inputs?e.inputs.map(ParamType.fromObject):[],payable:r.payable,stateMutability:r.stateMutability,gas:e.gas?t.from(e.gas):null};return new ConstructorFragment(F,n)}static fromString(t){let e={type:"constructor"};t=parseGas(t,e);let r=t.match(O);r&&"constructor"===r[1].trim()||_.throwArgumentError("invalid constructor string","value",t);e.inputs=parseParams(r[2].trim(),false);parseModifiers(r[3].trim(),e);return ConstructorFragment.fromObject(e)}static isConstructorFragment(t){return t&&t._isFragment&&"constructor"===t.type}}class FunctionFragment extends ConstructorFragment{format(t){t||(t=C.sighash);C[t]||_.throwArgumentError("invalid format type","format",t);if(t===C.json)return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:"nonpayable"!==this.stateMutability?this.stateMutability:void 0,payable:this.payable,gas:this.gas?this.gas.toNumber():void 0,inputs:this.inputs.map((e=>JSON.parse(e.format(t)))),outputs:this.outputs.map((e=>JSON.parse(e.format(t))))});let e="";t!==C.sighash&&(e+="function ");e+=this.name+"("+this.inputs.map((e=>e.format(t))).join(t===C.full?", ":",")+") ";if(t!==C.sighash){this.stateMutability?"nonpayable"!==this.stateMutability&&(e+=this.stateMutability+" "):this.constant&&(e+="view ");this.outputs&&this.outputs.length&&(e+="returns ("+this.outputs.map((e=>e.format(t))).join(", ")+") ");null!=this.gas&&(e+="@"+this.gas.toString()+" ")}return e.trim()}static from(t){return"string"===typeof t?FunctionFragment.fromString(t):FunctionFragment.fromObject(t)}static fromObject(e){if(FunctionFragment.isFunctionFragment(e))return e;"function"!==e.type&&_.throwArgumentError("invalid function object","value",e);let r=verifyState(e);const n={type:e.type,name:verifyIdentifier(e.name),constant:r.constant,inputs:e.inputs?e.inputs.map(ParamType.fromObject):[],outputs:e.outputs?e.outputs.map(ParamType.fromObject):[],payable:r.payable,stateMutability:r.stateMutability,gas:e.gas?t.from(e.gas):null};return new FunctionFragment(F,n)}static fromString(t){let e={type:"function"};t=parseGas(t,e);let r=t.split(" returns ");r.length>2&&_.throwArgumentError("invalid function string","value",t);let n=r[0].match(O);n||_.throwArgumentError("invalid function signature","value",t);e.name=n[1].trim();e.name&&verifyIdentifier(e.name);e.inputs=parseParams(n[2],false);parseModifiers(n[3].trim(),e);if(r.length>1){let n=r[1].match(O);""==n[1].trim()&&""==n[3].trim()||_.throwArgumentError("unexpected tokens","value",t);e.outputs=parseParams(n[2],false)}else e.outputs=[];return FunctionFragment.fromObject(e)}static isFunctionFragment(t){return t&&t._isFragment&&"function"===t.type}}function checkForbidden(t){const e=t.format();"Error(string)"!==e&&"Panic(uint256)"!==e||_.throwArgumentError(`cannot specify user defined ${e} error`,"fragment",t);return t}class ErrorFragment extends Fragment{format(t){t||(t=C.sighash);C[t]||_.throwArgumentError("invalid format type","format",t);if(t===C.json)return JSON.stringify({type:"error",name:this.name,inputs:this.inputs.map((e=>JSON.parse(e.format(t))))});let e="";t!==C.sighash&&(e+="error ");e+=this.name+"("+this.inputs.map((e=>e.format(t))).join(t===C.full?", ":",")+") ";return e.trim()}static from(t){return"string"===typeof t?ErrorFragment.fromString(t):ErrorFragment.fromObject(t)}static fromObject(t){if(ErrorFragment.isErrorFragment(t))return t;"error"!==t.type&&_.throwArgumentError("invalid error object","value",t);const e={type:t.type,name:verifyIdentifier(t.name),inputs:t.inputs?t.inputs.map(ParamType.fromObject):[]};return checkForbidden(new ErrorFragment(F,e))}static fromString(t){let e={type:"error"};let r=t.match(O);r||_.throwArgumentError("invalid error signature","value",t);e.name=r[1].trim();e.name&&verifyIdentifier(e.name);e.inputs=parseParams(r[2],false);return checkForbidden(ErrorFragment.fromObject(e))}static isErrorFragment(t){return t&&t._isFragment&&"error"===t.type}}function verifyType(t){t.match(/^uint($|[^1-9])/)?t="uint256"+t.substring(4):t.match(/^int($|[^1-9])/)&&(t="int256"+t.substring(3));return t}const S=new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");function verifyIdentifier(t){t&&t.match(S)||_.throwArgumentError(`invalid identifier "${t}"`,"value",t);return t}const O=new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");function splitNesting(t){t=t.trim();let e=[];let r="";let n=0;for(let a=0;a<t.length;a++){let s=t[a];if(","===s&&0===n){e.push(r);r=""}else{r+=s;if("("===s)n++;else if(")"===s){n--;-1===n&&_.throwArgumentError("unbalanced parenthesis","value",t)}}}r&&e.push(r);return e}"use strict";const j=new a(v);function checkResultErrors(t){const e=[];const checkErrors=function(t,r){if(Array.isArray(r))for(let n in r){const a=t.slice();a.push(n);try{checkErrors(a,r[n])}catch(t){e.push({path:a,error:t})}}};checkErrors([],t);return e}class Coder{constructor(t,e,r,n){this.name=t;this.type=e;this.localName=r;this.dynamic=n}_throwError(t,e){j.throwArgumentError(t,this.localName,e)}}class Writer{constructor(t){e(this,"wordSize",t||32);this._data=[];this._dataLength=0;this._padding=new Uint8Array(t)}get data(){return s(this._data)}get length(){return this._dataLength}_writeData(t){this._data.push(t);this._dataLength+=t.length;return t.length}appendWriter(t){return this._writeData(o(t._data))}writeBytes(t){let e=i(t);const r=e.length%this.wordSize;r&&(e=o([e,this._padding.slice(r)]));return this._writeData(e)}_getValue(e){let r=i(t.from(e));r.length>this.wordSize&&j.throwError("value out-of-bounds",a.errors.BUFFER_OVERRUN,{length:this.wordSize,offset:r.length});r.length%this.wordSize&&(r=o([this._padding.slice(r.length%this.wordSize),r]));return r}writeValue(t){return this._writeData(this._getValue(t))}writeUpdatableValue(){const t=this._data.length;this._data.push(this._padding);this._dataLength+=this.wordSize;return e=>{this._data[t]=this._getValue(e)}}}class Reader{constructor(t,r,n,a){e(this,"_data",i(t));e(this,"wordSize",r||32);e(this,"_coerceFunc",n);e(this,"allowLoose",a);this._offset=0}get data(){return u(this._data)}get consumed(){return this._offset}static coerce(t,e){let r=t.match("^u?int([0-9]+)$");r&&parseInt(r[1])<=48&&(e=e.toNumber());return e}coerce(t,e){return this._coerceFunc?this._coerceFunc(t,e):Reader.coerce(t,e)}_peekBytes(t,e,r){let n=Math.ceil(e/this.wordSize)*this.wordSize;this._offset+n>this._data.length&&(this.allowLoose&&r&&this._offset+e<=this._data.length?n=e:j.throwError("data out-of-bounds",a.errors.BUFFER_OVERRUN,{length:this._data.length,offset:this._offset+n}));return this._data.slice(this._offset,this._offset+n)}subReader(t){return new Reader(this._data.slice(this._offset+t),this.wordSize,this._coerceFunc,this.allowLoose)}readBytes(t,e){let r=this._peekBytes(0,t,!!e);this._offset+=r.length;return r.slice(0,t)}readValue(){return t.from(this.readBytes(this.wordSize))}}"use strict";class AddressCoder extends Coder{constructor(t){super("address","address",t,false)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(t,e){try{e=m(e)}catch(t){this._throwError(t.message,e)}return t.writeValue(e)}decode(t){return m(c(t.readValue().toHexString(),20))}}"use strict";class AnonymousCoder extends Coder{constructor(t){super(t.name,t.type,void 0,t.dynamic);this.coder=t}defaultValue(){return this.coder.defaultValue()}encode(t,e){return this.coder.encode(t,e)}decode(t){return this.coder.decode(t)}}"use strict";const N=new a(v);function pack(t,e,r){let n=null;if(Array.isArray(r))n=r;else if(r&&"object"===typeof r){let t={};n=e.map((e=>{const n=e.localName;n||N.throwError("cannot encode object for signature with missing names",a.errors.INVALID_ARGUMENT,{argument:"values",coder:e,value:r});t[n]&&N.throwError("cannot encode object for signature with duplicate names",a.errors.INVALID_ARGUMENT,{argument:"values",coder:e,value:r});t[n]=true;return r[n]}))}else N.throwArgumentError("invalid tuple value","tuple",r);e.length!==n.length&&N.throwArgumentError("types/value length mismatch","tuple",r);let s=new Writer(t.wordSize);let o=new Writer(t.wordSize);let i=[];e.forEach(((t,e)=>{let r=n[e];if(t.dynamic){let e=o.length;t.encode(o,r);let n=s.writeUpdatableValue();i.push((t=>{n(t+e)}))}else t.encode(s,r)}));i.forEach((t=>{t(s.length)}));let u=t.appendWriter(s);u+=t.appendWriter(o);return u}function unpack(t,e){let r=[];let n=t.subReader(0);e.forEach((e=>{let s=null;if(e.dynamic){let r=t.readValue();let o=n.subReader(r.toNumber());try{s=e.decode(o)}catch(t){if(t.code===a.errors.BUFFER_OVERRUN)throw t;s=t;s.baseType=e.name;s.name=e.localName;s.type=e.type}}else try{s=e.decode(t)}catch(t){if(t.code===a.errors.BUFFER_OVERRUN)throw t;s=t;s.baseType=e.name;s.name=e.localName;s.type=e.type}void 0!=s&&r.push(s)}));const s=e.reduce(((t,e)=>{const r=e.localName;if(r){t[r]||(t[r]=0);t[r]++}return t}),{});e.forEach(((t,e)=>{let n=t.localName;if(!n||1!==s[n])return;"length"===n&&(n="_length");if(null!=r[n])return;const a=r[e];a instanceof Error?Object.defineProperty(r,n,{enumerable:true,get:()=>{throw a}}):r[n]=a}));for(let t=0;t<r.length;t++){const e=r[t];e instanceof Error&&Object.defineProperty(r,t,{enumerable:true,get:()=>{throw e}})}return Object.freeze(r)}class ArrayCoder extends Coder{constructor(t,e,r){const n=t.type+"["+(e>=0?e:"")+"]";const a=-1===e||t.dynamic;super("array",n,r,a);this.coder=t;this.length=e}defaultValue(){const t=this.coder.defaultValue();const e=[];for(let r=0;r<this.length;r++)e.push(t);return e}encode(t,e){Array.isArray(e)||this._throwError("expected array value",e);let r=this.length;if(-1===r){r=e.length;t.writeValue(e.length)}N.checkArgumentCount(e.length,r,"coder array"+(this.localName?" "+this.localName:""));let n=[];for(let t=0;t<e.length;t++)n.push(this.coder);return pack(t,n,e)}decode(t){let e=this.length;if(-1===e){e=t.readValue().toNumber();32*e>t._data.length&&N.throwError("insufficient data length",a.errors.BUFFER_OVERRUN,{length:t._data.length,count:e})}let r=[];for(let t=0;t<e;t++)r.push(new AnonymousCoder(this.coder));return t.coerce(this.name,unpack(t,r))}}"use strict";class BooleanCoder extends Coder{constructor(t){super("bool","bool",t,false)}defaultValue(){return false}encode(t,e){return t.writeValue(e?1:0)}decode(t){return t.coerce(this.type,!t.readValue().isZero())}}"use strict";class DynamicBytesCoder extends Coder{constructor(t,e){super(t,t,e,true)}defaultValue(){return"0x"}encode(t,e){e=i(e);let r=t.writeValue(e.length);r+=t.writeBytes(e);return r}decode(t){return t.readBytes(t.readValue().toNumber(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(t){super("bytes",t)}decode(t){return t.coerce(this.name,u(super.decode(t)))}}"use strict";class FixedBytesCoder extends Coder{constructor(t,e){let r="bytes"+String(t);super(r,r,e,false);this.size=t}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+2*this.size)}encode(t,e){let r=i(e);r.length!==this.size&&this._throwError("incorrect data length",e);return t.writeBytes(r)}decode(t){return t.coerce(this.name,u(t.readBytes(this.size)))}}"use strict";class NullCoder extends Coder{constructor(t){super("null","",t,false)}defaultValue(){return null}encode(t,e){null!=e&&this._throwError("not null",e);return t.writeBytes([])}decode(t){t.readBytes(0);return t.coerce(this.name,null)}}"use strict";class NumberCoder extends Coder{constructor(t,e,r){const n=(e?"int":"uint")+8*t;super(n,n,r,false);this.size=t;this.signed=e}defaultValue(){return 0}encode(e,r){let n=t.from(r);let a=p.mask(8*e.wordSize);if(this.signed){let t=a.mask(8*this.size-1);(n.gt(t)||n.lt(t.add(d).mul(g)))&&this._throwError("value out-of-bounds",r)}else(n.lt(f)||n.gt(a.mask(8*this.size)))&&this._throwError("value out-of-bounds",r);n=n.toTwos(8*this.size).mask(8*this.size);this.signed&&(n=n.fromTwos(8*this.size).toTwos(8*e.wordSize));return e.writeValue(n)}decode(t){let e=t.readValue().mask(8*this.size);this.signed&&(e=e.fromTwos(8*this.size));return t.coerce(this.name,e)}}"use strict";class StringCoder extends DynamicBytesCoder{constructor(t){super("string",t)}defaultValue(){return""}encode(t,e){return super.encode(t,y(e))}decode(t){return b(super.decode(t))}}"use strict";class TupleCoder extends Coder{constructor(t,e){let r=false;const n=[];t.forEach((t=>{t.dynamic&&(r=true);n.push(t.type)}));const a="tuple("+n.join(",")+")";super("tuple",a,e,r);this.coders=t}defaultValue(){const t=[];this.coders.forEach((e=>{t.push(e.defaultValue())}));const e=this.coders.reduce(((t,e)=>{const r=e.localName;if(r){t[r]||(t[r]=0);t[r]++}return t}),{});this.coders.forEach(((r,n)=>{let a=r.localName;if(a&&1===e[a]){"length"===a&&(a="_length");null==t[a]&&(t[a]=t[n])}}));return Object.freeze(t)}encode(t,e){return pack(t,this.coders,e)}decode(t){return t.coerce(this.name,unpack(t,this.coders))}}"use strict";const P=new a(v);const k=new RegExp(/^bytes([0-9]*)$/);const M=new RegExp(/^(u?int)([0-9]*)$/);class AbiCoder{constructor(t){e(this,"coerceFunc",t||null)}_getCoder(t){switch(t.baseType){case"address":return new AddressCoder(t.name);case"bool":return new BooleanCoder(t.name);case"string":return new StringCoder(t.name);case"bytes":return new BytesCoder(t.name);case"array":return new ArrayCoder(this._getCoder(t.arrayChildren),t.arrayLength,t.name);case"tuple":return new TupleCoder((t.components||[]).map((t=>this._getCoder(t))),t.name);case"":return new NullCoder(t.name)}let e=t.type.match(M);if(e){let r=parseInt(e[2]||"256");(0===r||r>256||r%8!==0)&&P.throwArgumentError("invalid "+e[1]+" bit length","param",t);return new NumberCoder(r/8,"int"===e[1],t.name)}e=t.type.match(k);if(e){let r=parseInt(e[1]);(0===r||r>32)&&P.throwArgumentError("invalid bytes length","param",t);return new FixedBytesCoder(r,t.name)}return P.throwArgumentError("invalid type","type",t.type)}_getWordSize(){return 32}_getReader(t,e){return new Reader(t,this._getWordSize(),this.coerceFunc,e)}_getWriter(){return new Writer(this._getWordSize())}getDefaultValue(t){const e=t.map((t=>this._getCoder(ParamType.from(t))));const r=new TupleCoder(e,"_");return r.defaultValue()}encode(t,e){t.length!==e.length&&P.throwError("types/values length mismatch",a.errors.INVALID_ARGUMENT,{count:{types:t.length,values:e.length},value:{types:t,values:e}});const r=t.map((t=>this._getCoder(ParamType.from(t))));const n=new TupleCoder(r,"_");const s=this._getWriter();n.encode(s,e);return s.data}decode(t,e,r){const n=t.map((t=>this._getCoder(ParamType.from(t))));const a=new TupleCoder(n,"_");return a.decode(this._getReader(i(e),r))}}const R=new AbiCoder;"use strict";const V=new a(v);class LogDescription extends r{}class TransactionDescription extends r{}class ErrorDescription extends r{}class Indexed extends r{static isIndexed(t){return!!(t&&t._isIndexed)}}const z={"0x08c379a0":{signature:"Error(string)",name:"Error",inputs:["string"],reason:true},"0x4e487b71":{signature:"Panic(uint256)",name:"Panic",inputs:["uint256"]}};function wrapAccessError(t,e){const r=new Error(`deferred error during ABI decoding triggered accessing ${t}`);r.error=e;return r}class Interface{constructor(t){let r=[];r="string"===typeof t?JSON.parse(t):t;e(this,"fragments",r.map((t=>Fragment.from(t))).filter((t=>null!=t)));e(this,"_abiCoder",n(new.target,"getAbiCoder")());e(this,"functions",{});e(this,"errors",{});e(this,"events",{});e(this,"structs",{});this.fragments.forEach((t=>{let r=null;switch(t.type){case"constructor":if(this.deploy){V.warn("duplicate definition - constructor");return}e(this,"deploy",t);return;case"function":r=this.functions;break;case"event":r=this.events;break;case"error":r=this.errors;break;default:return}let n=t.format();r[n]?V.warn("duplicate definition - "+n):r[n]=t}));this.deploy||e(this,"deploy",ConstructorFragment.from({payable:false,type:"constructor"}));e(this,"_isInterface",true)}format(t){t||(t=C.full);t===C.sighash&&V.throwArgumentError("interface does not support formatting sighash","format",t);const e=this.fragments.map((e=>e.format(t)));return t===C.json?JSON.stringify(e.map((t=>JSON.parse(t)))):e}static getAbiCoder(){return R}static getAddress(t){return m(t)}static getSighash(t){return l(w(t.format()),0,4)}static getEventTopic(t){return w(t.format())}getFunction(t){if(h(t)){for(const e in this.functions)if(t===this.getSighash(e))return this.functions[e];V.throwArgumentError("no matching function","sighash",t)}if(-1===t.indexOf("(")){const e=t.trim();const r=Object.keys(this.functions).filter((t=>t.split("(")[0]===e));0===r.length?V.throwArgumentError("no matching function","name",e):r.length>1&&V.throwArgumentError("multiple matching functions","name",e);return this.functions[r[0]]}const e=this.functions[FunctionFragment.fromString(t).format()];e||V.throwArgumentError("no matching function","signature",t);return e}getEvent(t){if(h(t)){const e=t.toLowerCase();for(const t in this.events)if(e===this.getEventTopic(t))return this.events[t];V.throwArgumentError("no matching event","topichash",e)}if(-1===t.indexOf("(")){const e=t.trim();const r=Object.keys(this.events).filter((t=>t.split("(")[0]===e));0===r.length?V.throwArgumentError("no matching event","name",e):r.length>1&&V.throwArgumentError("multiple matching events","name",e);return this.events[r[0]]}const e=this.events[EventFragment.fromString(t).format()];e||V.throwArgumentError("no matching event","signature",t);return e}getError(t){if(h(t)){const e=n(this.constructor,"getSighash");for(const r in this.errors){const n=this.errors[r];if(t===e(n))return this.errors[r]}V.throwArgumentError("no matching error","sighash",t)}if(-1===t.indexOf("(")){const e=t.trim();const r=Object.keys(this.errors).filter((t=>t.split("(")[0]===e));0===r.length?V.throwArgumentError("no matching error","name",e):r.length>1&&V.throwArgumentError("multiple matching errors","name",e);return this.errors[r[0]]}const e=this.errors[FunctionFragment.fromString(t).format()];e||V.throwArgumentError("no matching error","signature",t);return e}getSighash(t){if("string"===typeof t)try{t=this.getFunction(t)}catch(e){try{t=this.getError(t)}catch(t){throw e}}return n(this.constructor,"getSighash")(t)}getEventTopic(t){"string"===typeof t&&(t=this.getEvent(t));return n(this.constructor,"getEventTopic")(t)}_decodeParams(t,e){return this._abiCoder.decode(t,e)}_encodeParams(t,e){return this._abiCoder.encode(t,e)}encodeDeploy(t){return this._encodeParams(this.deploy.inputs,t||[])}decodeErrorResult(t,e){"string"===typeof t&&(t=this.getError(t));const r=i(e);u(r.slice(0,4))!==this.getSighash(t)&&V.throwArgumentError(`data signature does not match error ${t.name}.`,"data",u(r));return this._decodeParams(t.inputs,r.slice(4))}encodeErrorResult(t,e){"string"===typeof t&&(t=this.getError(t));return u(o([this.getSighash(t),this._encodeParams(t.inputs,e||[])]))}decodeFunctionData(t,e){"string"===typeof t&&(t=this.getFunction(t));const r=i(e);u(r.slice(0,4))!==this.getSighash(t)&&V.throwArgumentError(`data signature does not match function ${t.name}.`,"data",u(r));return this._decodeParams(t.inputs,r.slice(4))}encodeFunctionData(t,e){"string"===typeof t&&(t=this.getFunction(t));return u(o([this.getSighash(t),this._encodeParams(t.inputs,e||[])]))}decodeFunctionResult(t,e){"string"===typeof t&&(t=this.getFunction(t));let r=i(e);let n=null;let s="";let o=null;let c=null;let l=null;switch(r.length%this._abiCoder._getWordSize()){case 0:try{return this._abiCoder.decode(t.outputs,r)}catch(t){}break;case 4:{const t=u(r.slice(0,4));const e=z[t];if(e){o=this._abiCoder.decode(e.inputs,r.slice(4));c=e.name;l=e.signature;e.reason&&(n=o[0]);"Error"===c?s=`; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}`:"Panic"===c&&(s=`; VM Exception while processing transaction: reverted with panic code ${o[0]}`)}else try{const e=this.getError(t);o=this._abiCoder.decode(e.inputs,r.slice(4));c=e.name;l=e.format()}catch(t){}break}}return V.throwError("call revert exception"+s,a.errors.CALL_EXCEPTION,{method:t.format(),data:u(e),errorArgs:o,errorName:c,errorSignature:l,reason:n})}encodeFunctionResult(t,e){"string"===typeof t&&(t=this.getFunction(t));return u(this._abiCoder.encode(t.outputs,e||[]))}encodeFilterTopics(e,r){"string"===typeof e&&(e=this.getEvent(e));r.length>e.inputs.length&&V.throwError("too many arguments for "+e.format(),a.errors.UNEXPECTED_ARGUMENT,{argument:"values",value:r});let n=[];e.anonymous||n.push(this.getEventTopic(e));const encodeTopic=(e,r)=>{if("string"===e.type)return w(r);if("bytes"===e.type)return E(u(r));"bool"===e.type&&"boolean"===typeof r&&(r=r?"0x01":"0x00");e.type.match(/^u?int/)&&(r=t.from(r).toHexString());"address"===e.type&&this._abiCoder.encode(["address"],[r]);return c(u(r),32)};r.forEach(((t,r)=>{let a=e.inputs[r];a.indexed?null==t?n.push(null):"array"===a.baseType||"tuple"===a.baseType?V.throwArgumentError("filtering with tuples or arrays not supported","contract."+a.name,t):Array.isArray(t)?n.push(t.map((t=>encodeTopic(a,t)))):n.push(encodeTopic(a,t)):null!=t&&V.throwArgumentError("cannot filter non-indexed parameters; must be null","contract."+a.name,t)}));while(n.length&&null===n[n.length-1])n.pop();return n}encodeEventLog(t,e){"string"===typeof t&&(t=this.getEvent(t));const r=[];const n=[];const a=[];t.anonymous||r.push(this.getEventTopic(t));e.length!==t.inputs.length&&V.throwArgumentError("event arguments/values mismatch","values",e);t.inputs.forEach(((t,s)=>{const o=e[s];if(t.indexed)if("string"===t.type)r.push(w(o));else if("bytes"===t.type)r.push(E(o));else{if("tuple"===t.baseType||"array"===t.baseType)throw new Error("not implemented");r.push(this._abiCoder.encode([t.type],[o]))}else{n.push(t);a.push(o)}}));return{data:this._abiCoder.encode(n,a),topics:r}}decodeEventLog(t,e,r){"string"===typeof t&&(t=this.getEvent(t));if(null!=r&&!t.anonymous){let e=this.getEventTopic(t);h(r[0],32)&&r[0].toLowerCase()===e||V.throwError("fragment/topic mismatch",a.errors.INVALID_ARGUMENT,{argument:"topics[0]",expected:e,value:r[0]});r=r.slice(1)}let n=[];let s=[];let i=[];t.inputs.forEach(((t,e)=>{if(t.indexed)if("string"===t.type||"bytes"===t.type||"tuple"===t.baseType||"array"===t.baseType){n.push(ParamType.fromObject({type:"bytes32",name:t.name}));i.push(true)}else{n.push(t);i.push(false)}else{s.push(t);i.push(false)}}));let u=null!=r?this._abiCoder.decode(n,o(r)):null;let c=this._abiCoder.decode(s,e,true);let l=[];let m=0,p=0;t.inputs.forEach(((t,e)=>{if(t.indexed)if(null==u)l[e]=new Indexed({_isIndexed:true,hash:null});else if(i[e])l[e]=new Indexed({_isIndexed:true,hash:u[p++]});else try{l[e]=u[p++]}catch(t){l[e]=t}else try{l[e]=c[m++]}catch(t){l[e]=t}if(t.name&&null==l[t.name]){const r=l[e];r instanceof Error?Object.defineProperty(l,t.name,{enumerable:true,get:()=>{throw wrapAccessError(`property ${JSON.stringify(t.name)}`,r)}}):l[t.name]=r}}));for(let t=0;t<l.length;t++){const e=l[t];e instanceof Error&&Object.defineProperty(l,t,{enumerable:true,get:()=>{throw wrapAccessError(`index ${t}`,e)}})}return Object.freeze(l)}parseTransaction(e){let r=this.getFunction(e.data.substring(0,10).toLowerCase());return r?new TransactionDescription({args:this._abiCoder.decode(r.inputs,"0x"+e.data.substring(10)),functionFragment:r,name:r.name,signature:r.format(),sighash:this.getSighash(r),value:t.from(e.value||"0")}):null}parseLog(t){let e=this.getEvent(t.topics[0]);return!e||e.anonymous?null:new LogDescription({eventFragment:e,name:e.name,signature:e.format(),topic:this.getEventTopic(e),args:this.decodeEventLog(e,t.data,t.topics)})}parseError(t){const e=u(t);let r=this.getError(e.substring(0,10).toLowerCase());return r?new ErrorDescription({args:this._abiCoder.decode(r.inputs,"0x"+e.substring(10)),errorFragment:r,name:r.name,signature:r.format(),sighash:this.getSighash(r)}):null}static isInterface(t){return!!(t&&t._isInterface)}}"use strict";export{AbiCoder,ConstructorFragment,ErrorFragment,EventFragment,C as FormatTypes,Fragment,FunctionFragment,Indexed,Interface,LogDescription,ParamType,TransactionDescription,checkResultErrors,R as defaultAbiCoder};

