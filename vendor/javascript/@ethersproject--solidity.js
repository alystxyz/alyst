import{BigNumber as r}from"@ethersproject/bignumber";import{zeroPad as t,arrayify as e,concat as n,hexlify as o}from"@ethersproject/bytes";import{keccak256 as s}from"@ethersproject/keccak256";import{sha256 as c}from"@ethersproject/sha2";import{toUtf8Bytes as a}from"@ethersproject/strings";import{Logger as i}from"@ethersproject/logger";const u="solidity/5.7.0";"use strict";const p=new RegExp("^bytes([0-9]+)$");const h=new RegExp("^(u?int)([0-9]*)$");const g=new RegExp("^(.*)\\[([0-9]*)\\]$");const m="0000000000000000000000000000000000000000000000000000000000000000";const f=new i(u);function _pack(o,s,c){switch(o){case"address":return c?t(s,32):e(s);case"string":return a(s);case"bytes":return e(s);case"bool":s=s?"0x01":"0x00";return c?t(s,32):e(s)}let i=o.match(h);if(i){let e=parseInt(i[2]||"256");(i[2]&&String(e)!==i[2]||e%8!==0||0===e||e>256)&&f.throwArgumentError("invalid number type","type",o);c&&(e=256);s=r.from(s).toTwos(e);return t(s,e/8)}i=o.match(p);if(i){const r=parseInt(i[1]);(String(r)!==i[1]||0===r||r>32)&&f.throwArgumentError("invalid bytes type","type",o);e(s).byteLength!==r&&f.throwArgumentError(`invalid value for ${o}`,"value",s);return c?e((s+m).substring(0,66)):s}i=o.match(g);if(i&&Array.isArray(s)){const r=i[1];const t=parseInt(i[2]||String(s.length));t!=s.length&&f.throwArgumentError(`invalid array length for ${o}`,"value",s);const e=[];s.forEach((function(t){e.push(_pack(r,t,true))}));return n(e)}return f.throwArgumentError("invalid type","type",o)}function pack(r,t){r.length!=t.length&&f.throwArgumentError("wrong number of values; expected ${ types.length }","values",t);const e=[];r.forEach((function(r,n){e.push(_pack(r,t[n]))}));return o(n(e))}function keccak256(r,t){return s(pack(r,t))}function sha256(r,t){return c(pack(r,t))}export{keccak256,pack,sha256};

