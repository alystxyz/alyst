import{isBytesLike as r,arrayify as t,hexlify as e}from"@ethersproject/bytes";import{Logger as o}from"@ethersproject/logger";const n="rlp/5.7.0";"use strict";const s=new o(n);function arrayifyInteger(r){const t=[];while(r){t.unshift(255&r);r>>=8}return t}function unarrayifyInteger(r,t,e){let o=0;for(let n=0;n<e;n++)o=256*o+r[t+n];return o}function _encode(e){if(Array.isArray(e)){let r=[];e.forEach((function(t){r=r.concat(_encode(t))}));if(r.length<=55){r.unshift(192+r.length);return r}const t=arrayifyInteger(r.length);t.unshift(247+t.length);return t.concat(r)}r(e)||s.throwArgumentError("RLP object must be BytesLike","object",e);const o=Array.prototype.slice.call(t(e));if(1===o.length&&o[0]<=127)return o;if(o.length<=55){o.unshift(128+o.length);return o}const n=arrayifyInteger(o.length);n.unshift(183+n.length);return n.concat(o)}function encode(r){return e(_encode(r))}function _decodeChildren(r,t,e,n){const c=[];while(e<t+1+n){const h=_decode(r,e);c.push(h.result);e+=h.consumed;e>t+1+n&&s.throwError("child data too short",o.errors.BUFFER_OVERRUN,{})}return{consumed:1+n,result:c}}function _decode(r,t){0===r.length&&s.throwError("data too short",o.errors.BUFFER_OVERRUN,{});if(r[t]>=248){const e=r[t]-247;t+1+e>r.length&&s.throwError("data short segment too short",o.errors.BUFFER_OVERRUN,{});const n=unarrayifyInteger(r,t+1,e);t+1+e+n>r.length&&s.throwError("data long segment too short",o.errors.BUFFER_OVERRUN,{});return _decodeChildren(r,t,t+1+e,e+n)}if(r[t]>=192){const e=r[t]-192;t+1+e>r.length&&s.throwError("data array too short",o.errors.BUFFER_OVERRUN,{});return _decodeChildren(r,t,t+1,e)}if(r[t]>=184){const n=r[t]-183;t+1+n>r.length&&s.throwError("data array too short",o.errors.BUFFER_OVERRUN,{});const c=unarrayifyInteger(r,t+1,n);t+1+n+c>r.length&&s.throwError("data array too short",o.errors.BUFFER_OVERRUN,{});const h=e(r.slice(t+1+n,t+1+n+c));return{consumed:1+n+c,result:h}}if(r[t]>=128){const n=r[t]-128;t+1+n>r.length&&s.throwError("data too short",o.errors.BUFFER_OVERRUN,{});const c=e(r.slice(t+1,t+1+n));return{consumed:1+n,result:c}}return{consumed:1,result:e(r[t])}}function decode(r){const e=t(r);const o=_decode(e,0);o.consumed!==e.length&&s.throwArgumentError("invalid rlp data","data",r);return o.result}export{decode,encode};

