import{Base58 as e}from"@ethersproject/basex";import{hexZeroPad as t,hexlify as n,concat as r,hexDataSlice as i,arrayify as o}from"@ethersproject/bytes";import{BigNumber as s}from"@ethersproject/bignumber";import{toUtf8Bytes as c,UnicodeNormalizationForm as l}from"@ethersproject/strings";import{pbkdf2 as h}from"@ethersproject/pbkdf2";import{defineReadOnly as a}from"@ethersproject/properties";import{SigningKey as d}from"@ethersproject/signing-key";import{sha256 as f,ripemd160 as p,computeHmac as m,SupportedAlgorithm as u}from"@ethersproject/sha2";import{computeAddress as g}from"@ethersproject/transactions";import{wordlists as y}from"@ethersproject/wordlists";import{Logger as w}from"@ethersproject/logger";const b="hdnode/5.7.0";"use strict";const v=new w(b);const E=s.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const x=c("Bitcoin seed");const K=2147483648;function getUpperMask(e){return(1<<e)-1<<8-e}function getLowerMask(e){return(1<<e)-1}function bytes32(e){return t(n(e),32)}function base58check(t){return e.encode(r([t,i(f(f(t)),0,4)]))}function getWordlist(e){if(null==e)return y.en;if("string"===typeof e){const t=y[e];null==t&&v.throwArgumentError("unknown locale","wordlist",e);return t}return e}const D={};const k="m/44'/60'/0'/0/0";class HDNode{constructor(e,t,r,o,s,c,l,h){if(e!==D)throw new Error("HDNode constructor cannot be called directly");if(t){const e=new d(t);a(this,"privateKey",e.privateKey);a(this,"publicKey",e.compressedPublicKey)}else{a(this,"privateKey",null);a(this,"publicKey",n(r))}a(this,"parentFingerprint",o);a(this,"fingerprint",i(p(f(this.publicKey)),0,4));a(this,"address",g(this.publicKey));a(this,"chainCode",s);a(this,"index",c);a(this,"depth",l);if(null==h){a(this,"mnemonic",null);a(this,"path",null)}else if("string"===typeof h){a(this,"mnemonic",null);a(this,"path",h)}else{a(this,"mnemonic",h);a(this,"path",h.path)}}get extendedKey(){if(this.depth>=256)throw new Error("Depth too large!");return base58check(r([null!=this.privateKey?"0x0488ADE4":"0x0488B21E",n(this.depth),this.parentFingerprint,t(n(this.index),4),this.chainCode,null!=this.privateKey?r(["0x00",this.privateKey]):this.publicKey]))}neuter(){return new HDNode(D,null,this.publicKey,this.parentFingerprint,this.chainCode,this.index,this.depth,this.path)}_derive(e){if(e>4294967295)throw new Error("invalid index - "+String(e));let t=this.path;t&&(t+="/"+(e&~K));const r=new Uint8Array(37);if(e&K){if(!this.privateKey)throw new Error("cannot derive child of neutered node");r.set(o(this.privateKey),1);t&&(t+="'")}else r.set(o(this.publicKey));for(let t=24;t>=0;t-=8)r[33+(t>>3)]=e>>24-t&255;const i=o(m(u.sha512,this.chainCode,r));const c=i.slice(0,32);const l=i.slice(32);let h=null;let a=null;if(this.privateKey)h=bytes32(s.from(c).add(this.privateKey).mod(E));else{const e=new d(n(c));a=e._addPoint(this.publicKey)}let f=t;const p=this.mnemonic;p&&(f=Object.freeze({phrase:p.phrase,path:t,locale:p.locale||"en"}));return new HDNode(D,h,a,this.fingerprint,bytes32(l),e,this.depth+1,f)}derivePath(e){const t=e.split("/");if(0===t.length||"m"===t[0]&&0!==this.depth)throw new Error("invalid path - "+e);"m"===t[0]&&t.shift();let n=this;for(let e=0;e<t.length;e++){const r=t[e];if(r.match(/^[0-9]+'$/)){const e=parseInt(r.substring(0,r.length-1));if(e>=K)throw new Error("invalid path index - "+r);n=n._derive(K+e)}else{if(!r.match(/^[0-9]+$/))throw new Error("invalid path component - "+r);{const e=parseInt(r);if(e>=K)throw new Error("invalid path index - "+r);n=n._derive(e)}}}return n}static _fromSeed(e,t){const n=o(e);if(n.length<16||n.length>64)throw new Error("invalid seed");const r=o(m(u.sha512,x,n));return new HDNode(D,bytes32(r.slice(0,32)),null,"0x00000000",bytes32(r.slice(32)),0,0,t)}static fromMnemonic(e,t,n){n=getWordlist(n);e=entropyToMnemonic(mnemonicToEntropy(e,n),n);return HDNode._fromSeed(mnemonicToSeed(e,t),{phrase:e,path:"m",locale:n.locale})}static fromSeed(e){return HDNode._fromSeed(e,null)}static fromExtendedKey(t){const r=e.decode(t);82===r.length&&base58check(r.slice(0,78))===t||v.throwArgumentError("invalid extended key","extendedKey","[REDACTED]");const i=r[4];const o=n(r.slice(5,9));const s=parseInt(n(r.slice(9,13)).substring(2),16);const c=n(r.slice(13,45));const l=r.slice(45,78);switch(n(r.slice(0,4))){case"0x0488b21e":case"0x043587cf":return new HDNode(D,null,n(l),o,c,s,i,null);case"0x0488ade4":case"0x04358394 ":if(0!==l[0])break;return new HDNode(D,n(l.slice(1)),null,o,c,s,i,null)}return v.throwArgumentError("invalid extended key","extendedKey","[REDACTED]")}}function mnemonicToSeed(e,t){t||(t="");const n=c("mnemonic"+t,l.NFKD);return h(c(e,l.NFKD),n,2048,64,"sha512")}function mnemonicToEntropy(e,t){t=getWordlist(t);v.checkNormalize();const r=t.split(e);if(r.length%3!==0)throw new Error("invalid mnemonic");const i=o(new Uint8Array(Math.ceil(11*r.length/8)));let s=0;for(let e=0;e<r.length;e++){let n=t.getWordIndex(r[e].normalize("NFKD"));if(-1===n)throw new Error("invalid mnemonic");for(let e=0;e<11;e++){n&1<<10-e&&(i[s>>3]|=1<<7-s%8);s++}}const c=32*r.length/3;const l=r.length/3;const h=getUpperMask(l);const a=o(f(i.slice(0,c/8)))[0]&h;if(a!==(i[i.length-1]&h))throw new Error("invalid checksum");return n(i.slice(0,c/8))}function entropyToMnemonic(e,t){t=getWordlist(t);e=o(e);if(e.length%4!==0||e.length<16||e.length>32)throw new Error("invalid entropy");const n=[0];let r=11;for(let t=0;t<e.length;t++)if(r>8){n[n.length-1]<<=8;n[n.length-1]|=e[t];r-=8}else{n[n.length-1]<<=r;n[n.length-1]|=e[t]>>8-r;n.push(e[t]&getLowerMask(8-r));r+=3}const i=e.length/4;const s=o(f(e))[0]&getUpperMask(i);n[n.length-1]<<=i;n[n.length-1]|=s>>8-i;return t.join(n.map((e=>t.getWord(e))))}function isValidMnemonic(e,t){try{mnemonicToEntropy(e,t);return true}catch(e){}return false}function getAccountPath(e){("number"!==typeof e||e<0||e>=K||e%1)&&v.throwArgumentError("invalid account index","index",e);return`m/44'/60'/${e}'/0/0`}export{HDNode,k as defaultPath,entropyToMnemonic,getAccountPath,isValidMnemonic,mnemonicToEntropy,mnemonicToSeed};

